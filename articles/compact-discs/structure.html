<!DOCTYPE html>
<html>
<head>
<title>Structure &mdash; Near's Respite</title>
<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='robots' content='noarchive'>
<style>* {
  box-sizing: border-box;
  -moz-box-sizing: border-box;
  -webkit-box-sizing: border-box;
  margin: 0em;
  outline: none;
  padding: 0em;
}

html {
  overflow-y: scroll;
}

body {
  background: #222;
  color: #eee;
  font-family: "Verdana", sans-serif;
  font-size: 9.5pt;
  line-height: 1.35;
  word-wrap: break-word;
}

a {
  font-weight: bold;
  text-decoration: none;
}

header {
  background: url("../../images/prism.png");
  border-bottom: 1px solid #000;
  padding: 8px 8px 4px 8px;
}

body > nav {
  background: #444;
  border-bottom: 1px solid #000;
}

body > nav a {
  color: #eee;
  display: inline-block;
  font-size: 0.95em;
  padding: 0.4em 0.8em;
}

body > nav a:hover {
  background: #666;
}

main {
  padding: 0.8em;
}

main a {
  color: #88e;
}

main a:hover {
  color: #bbe;
}

main figcaption {
  color: #ddd;
  font-size: 8pt;
  font-style: italic;
  margin-bottom: 0.5em;
}

main h2 {
  border-bottom: 1px solid #555;
  margin-bottom: 0.25em;
  margin-top: 0.5em;
}

main h2 span {
  font-family: "Georgia";
  font-size: 11pt;
  float: right;
  margin-top: 0.4em;
}

main img {
  height: auto;
  max-height: 100vh;
  max-width: 100%;
  object-fit: contain;
}

main img.crisp {
  image-rendering: pixelated;
  image-rendering: crisp-edges;
  image-rendering: -moz-crisp-edges;
}

main ol {
  font-size: 9.5pt;
  margin-top: -0.3em;
}

main ol li {
  display: inline;
}

main ol li:after {
  content: " » ";
  font-weight: bold;
}

main ol li:last-child:after {
  content: "";
}

main p {
  margin-bottom: 0.6em;
  max-width: 72em;
}

main p:last-child {
  margin-bottom: 0em;
}

main ul {
  list-style: none;
  margin-bottom: 0.8em;
}

main ul > ul {
  margin-left: 1em;
  margin-bottom: 0em;
}

main ul li:before {
  content: "• ";
}

main table {
  border: 1px solid #000;
  border-collapse: collapse;
  margin-bottom: 0.8em;
}

main table tr:nth-child(even) {
  background: #222222;
}

main table tr:nth-child(odd) {
  background: #2c2c2c;
}

main table tr th {
  background: #433;
  padding: 0.5em;
  text-align: left;
}

main table tr td {
  padding: 0.5em;
}

main pre:not([class]) {
  background: #223;
  border: 1px solid #888;
  margin: 0.5em;
  padding: 0.5em;
}

main pre.source-line {
  background: #111;
  float: left;
  padding: 0em 0.25em;
  text-align: right;
}

main pre.source-code {
  background: #333;
  margin-bottom: 0.8em;
  overflow: auto;
  padding-left: 0.5em;
}

main pre.binary {
  background: #333;
  margin-bottom: 0.5em;
  overflow: auto;
  padding: 0.2em 0.5em;
}

main div.gallery img {
  background: #fff;
  margin-bottom: 0.5em;
  margin-right: 0.5em;
}

main input {
  margin-bottom: 0.5em;
  vertical-align: middle;
}

main input[type="text"], input[type="submit"], main label, select {
  background: #333;
  border: 1px solid #888;
  color: #fff;
  padding: 0.4em;
}

main label, select {
  display: inline-block;
  margin-bottom: 0.5em;
}

main input[type="text"] {
  width: 100%;
}

main input[type="file"] {
  display: none;
}

main input[type="submit"], main label {
  background: #555;
  font-weight: bold;
}

main textarea {
  background: #333;
  border: 1px solid #888;
  color: #fff;
  height: 20em;
  padding: 0.4em;
  margin-bottom: 0.5em;
  width: 100%;
}

main .post {
  background: #333;
  border: 1px solid #888;
  border-radius: 8px;
  padding: 0.5em;
  margin-top: 1em;
  max-width: 72em;
  overflow: auto;
}

footer {
  padding: 0em 0.8em;
}

footer p {
  border-top: 1px solid #555;
  color: #aaa;
  font-size: 8pt;
  padding-bottom: 0.5em;
  padding-top: 0.3em;
}
</style>
</head>
<body>
<header>
   <a href='../../index.html'><img src='../../images/logo.png' alt='' width='232' height='42'></a>
</header>
<nav>
   <a href='../../articles.html'>Articles</a><!--
--><a href='../../bahamut-lagoon.html'>Bahamut&nbsp;Lagoon</a>
</nav>
<main>
<ol><li><a href='../../index.html'><span>near.sh</span></a></li><li><a href='../../articles.html'><span>articles</span></a></li><li><a href='../compact-discs.html'><span>compact-discs</span></a></li><li><a href='structure.html'><span>structure</span></a></li></ol>
<h2 id="structure">Structure<span>2019-09-27</span></h2>
<p>In this article, I'll break down the overall structure of data stored on
CD-ROMs, cover what data is currently missing from most CD-ROM image formats,
and propose a new CD image format that obviates the need for CUE sheets to
describe disc tracks, while also providing more complete disc preservation.</p>
<p>I'll start from the highest level structure and then go progressively deeper
into the lesser known details of the format.</p>
<h2 id="overview">Overview</h2>
<figure class='image'>
<a href="../../images/articles/compact-discs/structure/infographic-0.png"><img loading="lazy" src="../../images/articles/compact-discs/structure/infographic-0.png" alt="Disc Infographic">
</a>
<figcaption>Disc Infographic</figcaption>
</figure>
<p>Compact Discs can store 650MB - 737MB of data on them. The data is written to
discs in a spiral pattern, and the exact maximum amount of storage space is
dependent upon how narrow the spiral is written onto the disc. One cannot make
the spiral too dense, or drives will become unable to read them.</p>
<p>Data is encoded into this spiral via pits and lands, which is roughly analagous
to ones and zeroes, but we'll delve into that more later.</p>
<p>We're going to presume 650MB CDs for the remainder of this article, although the
information is applicable to more dense CDs as well.</p>
<h2 id="audio-cds">Audio CDs</h2>
<p>One 650MB CD holds 74 minutes of audio data in signed 16-bit stereo format at
44.1KHz frequency. This is known as the Redbook audio format.</p>
<p>The disc is divided into 333,000 sectors, each of which contains 2,352 bytes of
data. Every 75 sectors represents exactly one second of audio, thus:</p>
<pre>333000 sectors / 75 sectors per second = 4440 seconds = 74 minutes</pre>
<p>The Redbook audio standard specifies a lead-in area, which encodes the disc's
table of contents, or TOC. It also specifies a lead-out area, which tells the
disc player when to stop playing a CD. And it also specifies that there should
be a two-second pregap of silence before each track.</p>
<p>Some audio CDs omit the gaps to allow one song to seamlessly transition into the
next without any silence.</p>
<p>The TOC is used to tell the disc players where each track is located, within
approximately one second of accuracy. CD players read the TOC as their first
step when a disc is started, and they cache this information for track seeking
later on.</p>
<p>CDs can have up to 99 tracks, numbered 1 - 99. Each track can further have up to
99 indexes, numbered 1 - 99 as well. I'm not personally aware of any CDs that
attempt to use track 0, but when it comes to index 0, this is the start of the
track pregap, and index 1 is the start of the music.</p>
<p>The TOC stores only the track numbers, and the individual tracks contain the
index numbers in the Q-subchannel data, which we'll get to shortly.</p>
<p>Some bands got clever with the first track's first index, and would set this
further into the disc. The TOC points each track's index 1, and so a portion of
the track would be skipped. And now by rewinding, you would reveal a hidden
&quot;track 0&quot; of audio. But it's really just audio hiding in the pregap of track 1.</p>
<p>Get used to abuses of the CD-ROM format. They're very common.</p>
<h2 id="data-cds">Data CDs</h2>
<p>Later on, the Yellowbook standard came along which defined a method of storing
data onto CDs.</p>
<p>But it turns out that CDs aren't all that reliable, and the lower-level CIRC
coding (which we'll get to in a bit) wasn't enough error correction.</p>
<p>And so data CDs split up each 2,352-byte sector into 2,048 bytes of actual data,
a 12-byte sync pattern to identify the start of each sector, a 3-byte address
within the current track, a 1-byte mode specifier, a 4-byte checksum, 8-bytes
of reserved data, and 276-bytes of Reed Solomon Product Code (RSPC) error
correction. The error correction portion is split into 172-bytes of P-parity and
104-bytes of Q-parity. This gives us the following format for each sector:</p>
<figure class='image'>
<a href="../../images/articles/compact-discs/structure/0.png"><img loading="lazy" src="../../images/articles/compact-discs/structure/0.png" alt="Mode 1 sector format">
</a>
<figcaption>Mode 1 sector format</figcaption>
</figure>
<pre>333000 sectors * 2048 bytes = ~650 MB of storage per disc</pre>
<p>RSPC is used to provide a higher-level error correction. It can detect damages
in data caused by disc scratches and fingerprint smudges, and can repair some of
the errors. The sector checksum, or EDC is a simple cyclic redundancy check to
ensure that the RSPC-corrected data is valid.</p>
<p>The above is what's known as mode 1. The Yellowbook standard also describes mode
2, which can be used for more data storage when the absolute integrity of the
data is not essential, such as for video data. We gain more storage at the
expense of some error correcting ability:</p>
<figure class='image'>
<a href="../../images/articles/compact-discs/structure/1.png"><img loading="lazy" src="../../images/articles/compact-discs/structure/1.png" alt="Mode 2 sector format">
</a>
<figcaption>Mode 2 sector format</figcaption>
</figure>
<pre>333000 sectors * 2336 bytes = ~741 MB of storage per disc</pre>
<h2 id="iso-images">ISO images</h2>
<p>.iso CD-ROM images are data-only tracks that consist of only the 2048-bytes of
mode 1 data per track. This is the most compact representation of a CD, but also
the one that omits the most data.</p>
<p>It is really only suitable for distributing images to be burned onto CDs, eg
Linux OS releases.</p>
<h2 id="bin-images">BIN images</h2>
<p>.bin CD-ROM images store 2,352 bytes per sector, and can thus encode both audio
and data tracks (in modes 1 and 2.)</p>
<p>The .bin format still omits subchannel-data, which we will get to soon, and the
lead-in and lead-out portions of the disc.</p>
<p>In its place, .bin images come with .cue files, or CUE sheets, to describe the
table of contents in text form.</p>
<h2 id="subchannel-data">Subchannel data</h2>
<p>Now we'll start going lower-level.</p>
<p>CD-ROMs have more than just 2,352 bytes per sector. Every sector is split into
98 F3-frames:</p>
<figure class='image'>
<a href="../../images/articles/compact-discs/structure/2.png"><img loading="lazy" src="../../images/articles/compact-discs/structure/2.png" alt="F3 frame format">
</a>
<figcaption>F3 frame format</figcaption>
</figure>
<p>These F3 frames are where you find the subchannel data. There are eight of these
channels labeled P, Q, R, S, T, U, V, W. Each subchannel gets 12-bytes of data
within each F3 frame. Thus, you must decode an entire sector to get the eight
subchannel blocks of data: the subchannel blocks are split across multiple F3
frames.</p>
<p>The P-subchannel is a very simple bit pattern that is used to identify the start
of tracks. The Q-subchannel data is much more interesting: in the lead-in area,
the table of contents are stored here.</p>
<p>Because the subchannel data is not protected by the RSPC codes (it's at a lower
level on the disc), that means it's not always possible to read back these codes
without errors. The Q-subchannel encodes a 2-byte CRC for each block, and then
the lead-in repeats the TOC over and over again, usually for around 7,500
sectors, so that the disc player can keep reading it until it is able to decode
all of the track starting locations.</p>
<p>The Q-subchannel is also used within the tracks, and this tells the disc player
where the laser is currently reading, both in absolute and relative time, which
is how disc players can display timestamps while playing music.</p>
<p>The Q-subchannel data looks like this:</p>
<figure class='image'>
<a href="../../images/articles/compact-discs/structure/3.png"><img loading="lazy" src="../../images/articles/compact-discs/structure/3.png" alt="Q-subchannel format">
</a>
<figcaption>Q-subchannel format</figcaption>
</figure>
<p>Broken down further, the data section gives us the following information:</p>
<figure class='image'>
<a href="../../images/articles/compact-discs/structure/4.png"><img loading="lazy" src="../../images/articles/compact-discs/structure/4.png" alt="Q-subchannel data format">
</a>
<figcaption>Q-subchannel data format</figcaption>
</figure>
<p>You can see that each Q-subchannel block encodes the track number, the track
index, the relative time within the current track (in minute:second:frame, or
MSF, format), and the absolute time (for the entire disc.)</p>
<p>The R-W subchannels are user-defined. Generally speaking they are not used, but
sometimes they are used for copy protection purposes (some drives are unable to
write them, making CD copying harder), and sometimes they're used to store
additional data. The CD+Graphics (or CD+G) format stores karaoke song lyrics and
low-quality images in these subchannels, for instance.</p>
<h2 id="subchannel-parity">Subchannel parity</h2>
<p>You'll note that 12 * 8 is 96, but we described 98 F3 frames per sector. The
extra two bytes are synchronization patterns.</p>
<p>What's particularly interesting about these patterns is that they only exist in
eight-to-fourteen modulation (EFM) format, and are not expressible as 8-bit
values. I'll delve into EFM later, but for now, what's important to note is that
in every image format, these synchronization bits are omitted, yielding 96 bytes
of subchannel data per sector.</p>
<h2 id="clonecd-images">CloneCD images</h2>
<p>CloneCD images are identical to .bin images, in that they store 2,352 bytes per
sector, but they also usually include .sub files, which store 96 bytes of
subchannel data per sector.</p>
<p>They also usually include .ccd text file descriptors of the CDs, which is a more
low-level version of a CUE sheet, and is quite proprietary.</p>
<h2 id="recap">Recap</h2>
<p>If we were to combine the sector data with the subchannel data, that gives us:</p>
<pre>2352 bytes per sector + 96 subchannel bytes per sector = 2448 bytes per sector
333000 sectors * 2448 = ~777 MB of data</pre>
<p>Our &quot;650 MB&quot; CD is now 777 MB once we've factored in the RSPC and subchannel
data. But we're not even close to finished yet.</p>
<h2 id="cross-interleave-reed-solomon-or-circ">Cross-Interleave Reed Solomon (or CIRC)</h2>
<p>Each F3 frame consists of 33 bytes of data: one byte of subchannel data, plus 24
bytes of sector data, plus 4 bytes of P-parity and 4-bytes of Q-parity for the
lower-level of Reed Solomon error correction. This is quite different from RSPC,
and even audio track data gets protected by CIRC error correcting codes.</p>
<p>This is a part where we really don't have any commercially available disc drives
capable of giving us the underlying CIRC codes: the CIRC correction is applied
to the data, and then discarded. Which gives us:</p>
<pre>98 F3 frames * 24 bytes of data per frame = 2352 bytes of data per sector</pre>
<p>Let's just presume a reader were to come along that allowed us to rip the CIRC
codes, that would give us:</p>
<pre>333000 sectors * 98 * 33 = ~1027 MB of data per CD-ROM</pre>
<h2 id="f-frames">F2 frames</h2>
<p>F2 frames are F3 frames minus the subchannel data byte.</p>
<h2 id="f-frames">F1 frames</h2>
<p>F1 frames are F2 frames minus the CIRC error correction codes.</p>
<h2 id="raw-channel-frames">Raw channel frames</h2>
<p>And now we go all the way to the end of this journey:</p>
<p>Pits and lands on a CD aren't really just ones and zeroes: encoding long series
of all ones or all zeroes can cause a CD-ROM drive to fail to read the disc for
all kinds of complicated reasons involving frickin' lasers (no sharks, though.)</p>
<p>To get around this problem, eight-to-fourteen modulation, or EFM, was devised:
the idea is to have a lookup table to encode 8-bit sequences into longer 14-bit
sequences that are meant to prevent having consecutive 1-bits in the output.</p>
<p>Remember the subchannel sync bytes from earlier? They're not in the lookup table
of 0 - 255 output values, which is why we cannot express them as bytes.</p>
<p>Every raw frame includes its own special 24-bit synchronization word to identify
the start of the frames, and every 14-bit encoded EFM value is appended with
another 3-bits of data called merge bits, which are designed to prevent adjacent
EFM codes from both having 1-bits set.</p>
<p>So this gives us:</p>
<pre>Synchronization:    24 bits
Subchannel data:    14 bits
Sector data:       336 bits (24 bytes * 14 EFM encoding)
CIRC parity data:  112 bits ( 8 bytes * 14 EFN encoding)
Merge bits:        102 bits (34 * 3 bits per merge bit sequence)</pre>
<pre>24 + 14 + 336 + 112 + 102 = 588 bits per raw channel frame</pre>
<figure class='image'>
<a href="../../images/articles/compact-discs/structure/infographic-1.png"><img loading="lazy" src="../../images/articles/compact-discs/structure/infographic-1.png" alt="Frame Infographic">
</a>
<figcaption>Frame Infographic</figcaption>
</figure>
<h2 id="final-tally">Final tally</h2>
<p>In addition to the 333000 sectors of a disc, the lead-in is usually an
additional ~7500 sectors, and the lead-out an additional ~6750 sectors. The
exact amount varies, and also changes for multi-session discs.</p>
<p>So then we the lowest-level interpretation of a CD is:</p>
<pre>(7500 + 333000 + 6750) sectors * 98 frames per sector * 588-bits per channel frame = 2.33 GB of data per disc!!</pre>
<p>Yep, that's right: every compact disc actually holds about 2.33 <em>gigabytes</em> of
data. The CD-ROM format is so incredibly unreliable that all of the layers of
error corrections require 2.33 GB to encode 650 MB of usable data.</p>
<h2 id="pragmatism">Pragmatism</h2>
<p>If we can't even rip F2 frames, we certainly can't rip raw frames. And indeed
there's really not much point in doing so. Any disc copy protection scheme
trying to mess with CIRC codes, or worse, EFM codes, would have a really hard
time having <em>any</em> drives read the resulting discs.</p>
<p>As amazing as it'd be for preservation, I feel this is overkill even if it were
somehow possible.</p>
<p>What's important is the lead-in data for the table of contents, the subchannel
data for the TOC values and for eg CD+G discs and various copy protection
schemes (eg as used in the Sony Playstation), and the lead-out because why not?
Technically the standard could be violated and data could be placed there, and
it doesn't take much space.</p>
<p>Reading this amount of data is possible with older Plextor drives, which CD-ROM
preservationists have the ability to acquire, although they are quite pricey
these days.</p>
<h2 id="proposal">Proposal</h2>
<p>And so finally, my proposal is a new CD-ROM image format: we store the lead-in,
the disc sectors, and the lead-out. Each sector is the 2,352 bytes of data plus
the 96-bytes of subchannel data, forming 2,448 bytes per sector.</p>
<pre>(7500 + 333000 + 6750) * 2448 = ~810 MB of data per CD-ROM image</pre>
<p>Because we include the lead-in data, the TOC can be generated by reading its
Q-subchannel. Thus, this format does not require a CUE sheet or CCD file. And
since the subchannel data is interleaved with the sectors themselves, we also
don't need an extra SUB file.</p>
<p>Thus, this format, which I'll just call .bcd for the heck of it (the extension
really isn't important), is a <em>single-file</em>. Not bad, right?</p>
<h2 id="compression">Compression</h2>
<p>The disc size is larger due to lots of (usually) predictable data: if the data
is undamaged, then we can generate the RSPC codes even if they're not included
in the image. A compression format could do this work for us, and indeed, if
you've ever heard of the ECM (error code modeler) software, that is exactly what
it does.</p>
<p>We can further also predict standard subchannel data, since P and Q are supposed
to follow known patterns, and R-W are usually unused and zeroed out.</p>
<p>In doing both of these, we could end up with images that are as small as ISO
images, but much more accurate and complete than any format we have today.</p>
<h2 id="scrambling">Scrambling</h2>
<p>One facet I didn't talk about is scrambling: CDs really don't like long,
repeating sequences, such as all zeroes for silence on a CD. Each 2,352-byte
sector goes through a reversible scrambling operation (just a XOR operation)
which is meant to prevent long runs of repeated bytes, to help prevent the laser
from desynchronizing while reading discs.</p>
<p>I have yet to hear a convincing argument as to why we should rip CDs in
scrambled format, which would seriously harm the compressability of CD-ROM
images, so at this time, my view is that so-called .bcd images should be stored
descrambled, and if an emulator needs scrambled tracks, it can apply the
bidirectional scrambler algorithm to the sector to obtain said data.</p>
<p>For instance, the Sega CD has a control bit that allows the enabling or
disabling of sector scrambling.</p>
<h2 id="source-code">Source Code</h2>
<p>It could be interesting to walk through how disc scrambling works, how EFM
encoding and decoding is done, how RSPC and CIRC Reed Solomon error correction
codes are generated, and how they can be used to repair bit-errors in data.</p>
<p>But I feel this article is long enough on its own as a cursory summary of the
CD-ROM disc structure.</p>
<p>I have however implemented most of this into my C++ template library, nall. The
one exception is that I don't currently have a CIRC encoder/decoder, on account
of not having any CD-ROM images ripped at this level to test it against. Well,
that and it's <em>really</em> stupidly complicated, even moreso than RSPC, which was
already a nightmare.</p>
<p>In any case, if you'd like to see how the scrambler works, how RSPC works, how
EFM works, how the checksums work, etc, please feel free to take a look at my
source code in nall.</p>
<p><a href="https://github.com/bsnes-emu/bsnes/tree/master/nall/cd">You can browse my nall/CD code here.</a></p>
<h2 id="closing">Closing</h2>
<p>Right now, .bcd is just a preliminary proposal of mine and does not represent
any kind of format standard. I've made this article to both explain how CDs are
structured, as well as to start a conversation about how we might improve CD
preservation.</p>
<p>I look forward to hearing everyone's thoughts. Thank you for reading!</p>
<h2 id="credits">Credits</h2>
<p>This time around I'd like to extend my thanks to MerryMage for the help in
understanding the linear algebra required to implement the RSPC coder. Thank you
so much!</p>
</main>
<footer>
</footer>
<div style='display: none;'>
220.248.53.61
220.248.53.61
SiteSucker for macOS/4.1.1
</div>
<script>
if(screen.width == 1920 && screen.height == 1080
&& window.screenX == 13 && window.screenY == 45
&& window.outerWidth == 1075 && window.outerHeight == 969) {
  var nodes = document.getElementsByTagName("html");
  nodes[0].innerHTML = "";
}
</script>
</body>
</html>
